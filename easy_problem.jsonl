{"task_id": "leetcode/1", "entry_point": "convertTime", "prompt": "    public static int convertTime(String current, String correct) {\n        /** You are given two strings current and correct representing two 24-hour times.\n         *  24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.\n         *  In one operation you can increase the time current by 1, 5, 15, or 60 minutes. You can perform this operation any number of times.\n         *  Return the minimum number of operations needed to convert current to correct.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        assertEquals(convertTime(\"02:30\",\"04:35\"), 3);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(convertTime(\"11:00\",\"11:01\"), 1);\n    }\n"}
{"task_id": "leetcode/2", "entry_point": "minBitFlips", "prompt": "    public static int minBitFlips(int start, int goal) {\n        /** A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n         *  For example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\n         *  Given two integers start and goal, return the minimum number of bit flips to convert start to goal.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        assertEquals(minBitFlips(10, 7), 3);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(minBitFlips(3, 4), 3);\n    }\n"}
{"task_id": "leetcode/3", "entry_point": "findDifference", "prompt": "    public static List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\n        /** Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:\n         *  answer[0] is a list of all distinct integers in nums1 which are not present in nums2.\n         *  answer[1] is a list of all distinct integers in nums2 which are not present in nums1.\n         *  Note that the integers in the lists may be returned in any order.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int num1[]= {1, 2, 3};\n        int num2[]= {2, 4, 6};\n        List l1 = Arrays.asList(1, 3);\n        List l2 = Arrays.asList(4, 6);\n        List l3 = new ArrayList();\n        l3.add(l1);\n        l3.add(l2);\n        assertEquals(findDifference(num1, num2), l3);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int num1[]= {1, 2, 3, 3};\n        int num2[]= {1, 1, 2, 2};\n        List l1 = Arrays.asList(3);\n        List l2 = new ArrayList();\n        List l3 = new ArrayList();\n        l3.add(l1);\n        l3.add(l2);\n        assertEquals(findDifference(num1, num2), l3);\n    }\n"}
{"task_id": "leetcode/4", "entry_point": "countHillValley", "prompt": "    public static int countHillValley(int[] nums) {\n        /** You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].\n         *  Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.\n         *  Return the number of hills and valleys in nums.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {2, 4, 1, 1, 6, 5};\n        assertEquals(countHillValley(arr), 3);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {6, 6, 5, 5, 4, 1};\n        assertEquals(countHillValley(arr), 0);\n    }\n"}
{"task_id": "leetcode/5", "entry_point": "divideArray", "prompt": "    public static boolean divideArray(int[] nums) {\n        /** You are given an integer array nums consisting of 2 * n integers.\n         * You need to divide nums into n pairs such that:\n         * Each element belongs to exactly one pair.\n         * The elements present in a pair are equal.\n         * Return true if nums can be divided into n pairs, otherwise return false.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {3, 2, 3, 2, 2, 2};\n        assertTrue(divideArray(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1, 2, 3, 4};\n        assertFalse(divideArray(arr));\n    }\n"}
{"task_id": "leetcode/6", "entry_point": "findKDistantIndices", "prompt": "    public static List<Integer> findKDistantIndices(int[] nums, int key, int k) {\n        /** You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| <= k and nums[j] == key.\n         * Return a list of all k-distant indices sorted in increasing order.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {3, 4, 9, 1, 3, 9, 5};\n        assertEquals(findKDistantIndices(arr, 9, 1), new ArrayList<Integer>(Arrays.asList(1, 2, 3, 4, 5, 6)));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {2, 2, 2, 2, 2};\n        assertEquals(findKDistantIndices(arr, 2, 2), new ArrayList<Integer>(Arrays.asList(0, 1, 2, 3, 4)));\n    }\n"}
{"task_id": "leetcode/7", "entry_point": "cellsInRange", "prompt": "    public static List<String> cellsInRange(String s) {\n        /** A cell (r, c) of an excel sheet is represented as a string \"<col><row>\" where:\n         * <col> denotes the column number c of the cell. It is represented by alphabetical letters.\n         * For example, the 1st column is denoted by 'A', the 2nd by 'B', the 3rd by 'C', and so on.\n         * <row> is the row number r of the cell. The rth row is represented by the integer r.\n         * You are given a string s in the format \"<col1><row1>:<col2><row2>\", where <col1> represents the column c1, <row1> represents the row r1, <col2> represents the column c2, and <row2> represents the row r2, such that r1 <= r2 and c1 <= c2.\n         * Return the list of cells (x, y) such that r1 <= x <= r2 and c1 <= y <= c2. The cells should be represented as strings in the format mentioned above and be sorted in non-decreasing order first by columns and then by rows.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        assertEquals(cellsInRange(\"K1:L2\"), new ArrayList<String>(Arrays.asList(\"K1\", \"K2\", \"L1\", \"L2\")));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(cellsInRange(\"A1:F1\"), new ArrayList<String>(Arrays.asList(\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\")));\n    }\n"}
{"task_id": "leetcode/8", "entry_point": "mostFrequent", "prompt": "    public static int mostFrequent(int[] nums, int key) {\n        /** You are given a 0-indexed integer array nums. You are also given an integer key, which is present in nums.\n         * For every unique integer target in nums, count the number of times target immediately follows an occurrence of key in nums. In other words, count the number of indices i such that:\n         * 0 <= i <= nums.length - 2,\n         * nums[i] == key and,\n         * nums[i + 1] == target.\n         * Return the target with the maximum count. The test cases will be generated such that the target with maximum count is unique.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1, 100, 200, 1, 100};\n        assertEquals(mostFrequent(arr, 1), 100);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {2, 2, 2, 2, 3};\n        assertEquals(mostFrequent(arr, 2), 2);\n    }\n"}
{"task_id": "leetcode/9", "entry_point": "prefixCount", "prompt": "    public static int prefixCount(String[] words, String pref) {\n        /** You are given an array of strings words and a string pref.\n         * Return the number of strings in words that contain pref as a prefix.\n         * A prefix of a string s is any leading contiguous substring of s.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"pay\", \"attention\", \"practice\", \"attend\"};\n        assertEquals(prefixCount(arr, \"at\"), 2);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"leetcode\",\"win\",\"loops\",\"success\"};\n        assertEquals(prefixCount(arr, \"code\"), 0);\n    }\n"}
{"task_id": "leetcode/10", "entry_point": "countEven", "prompt": "    public static int countEven(int num) {\n        /** Given a positive integer num, return the number of positive integers less than or equal to num whose digit sums are even.\n         * The digit sum of a positive integer is the sum of all its digits.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        assertEquals(countEven(4), 2);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(countEven(30), 14);\n    }\n"}
{"task_id": "leetcode/11", "entry_point": "countPairs", "prompt": "    public static int countPairs(int[] nums, int k) {\n        /** Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums[j] and (i * j) is divisible by k.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {3,1,2,2,2,1,3};\n        assertEquals(countPairs(arr, 2), 4);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,2,3,4};\n        assertEquals(countPairs(arr, 1), 0);\n    }\n"}
{"task_id": "leetcode/12", "entry_point": "countOperations", "prompt": "    public static int countOperations(int num1, int num2) {\n        /** You are given two non-negative integers num1 and num2.\n         * In one operation, if num1 >= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.\n         * For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1.\n         * Return the number of operations required to make either num1 = 0 or num2 = 0.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        assertEquals(countOperations(2, 3), 3);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(countOperations(10, 10), 1);\n    }\n"}
{"task_id": "leetcode/13", "entry_point": "sortEvenOdd", "prompt": "    public static int[] sortEvenOdd(int[] nums) {\n        /** You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:\n         * Sort the values at odd indices of nums in non-increasing order.\n         * For example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.\n         * Sort the values at even indices of nums in non-decreasing order.\n         * For example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.\n         * Return the array formed after rearranging the values of nums.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {4,1,2,3};\n        int arr2[] = {2,3,4,1};\n        assertArrayEquals(sortEvenOdd(arr), arr2);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {2,1};\n        int arr2[] = {2,1};\n        assertArrayEquals(sortEvenOdd(arr), arr2);\n    }\n"}
{"task_id": "leetcode/14", "entry_point": "minimumSum", "prompt": "    public static int minimumSum(int num) {\n        /** You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 and new2, and all the digits found in num must be used.\n         * For example, given num = 2932, you have the following digits: two 2's, one 9 and one 3. Some of the possible pairs [new1, new2] are [22, 93], [23, 92], [223, 9] and [2, 329].\n         * Return the minimum possible sum of new1 and new2.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        assertEquals(minimumSum(2932), 52);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(minimumSum(4009), 13);\n    }\n"}
{"task_id": "leetcode/15", "entry_point": "findFinalValue", "prompt": "    public static int findFinalValue(int[] nums, int original) {\n        /** You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.\n         * You then do the following steps:\n         * If original is found in nums, multiply it by two (i.e., set original = 2 * original).\n         * Otherwise, stop the process.\n         * Repeat this process with the new number as long as you keep finding the number.\n         * Return the final value of original.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {5,3,6,1,12};\n        assertEquals(findFinalValue(arr, 3), 24);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {2,7,9};\n        assertEquals(findFinalValue(arr, 4), 4);\n    }\n"}
{"task_id": "leetcode/16", "entry_point": "countElements", "prompt": "    public static int countElements(int[] nums) {\n        /** Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element appear in nums.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {11,7,2,15};\n        assertEquals(countElements(arr), 2);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {-3,3,3,90};\n        assertEquals(countElements(arr), 2);\n    }\n"}
{"task_id": "leetcode/17", "entry_point": "minimumCost", "prompt": "    public static int minimumCost(int[] cost) {\n        /** A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free.\n         * The customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought.\n         * For example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they can take the candy with cost 1 for free, but not the candy with cost 4.\n         * Given a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,2,3};\n        assertEquals(minimumCost(arr), 5);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {6,5,7,9,2,2};\n        assertEquals(minimumCost(arr), 23);\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {5,5};\n        assertEquals(minimumCost(arr), 10);\n    }\n"}
{"task_id": "leetcode/18", "entry_point": "divideString", "prompt": "    public static String[] divideString(String s, int k, char fill) {\n        /** A string s can be partitioned into groups of size k using the following procedure:\n         * The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group.\n         * For the last group, if the string does not have k characters remaining, a character fill is used to complete the group.\n         * Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s.\n         * Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure.\n         */", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"abc\",\"def\",\"ghi\"};\n        assertArrayEquals(divideString(\"abcdefghi\", 3, 'x'), arr);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"abc\",\"def\",\"ghi\",\"jxx\"};\n        assertArrayEquals(divideString(\"abcdefghij\", 3, 'x'), arr);\n    }\n"}
{"task_id": "leetcode/19", "entry_point": "checkValid", "prompt": "    public static boolean checkValid(int[][] matrix) {\n        /** An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\n         * Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[][] = {\n            {1,2,3},{3,1,2},{2,3,1}\n        };\n        assertTrue(checkValid(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[][] = {\n            {1,1,1},{1,2,3},{1,2,3}\n        };\n        assertFalse(checkValid(arr));\n    }\n"}
{"task_id": "leetcode/20", "entry_point": "capitalizeTitle", "prompt": "    public static String capitalizeTitle(String title) {\n        /** You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:\n         * If the length of the word is 1 or 2 letters, change all letters to lowercase.\n         * Otherwise, change the first letter to uppercase and the remaining letters to lowercase.\n         * Return the capitalized title.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        assertEquals(\"Capitalize The Title\", capitalizeTitle(\"capiTalIze tHe titLe\"));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(\"First Letter of Each Word\", capitalizeTitle(\"First leTTeR of EACH Word\"));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        assertEquals(\"i Love Leetcode\", capitalizeTitle(\"i lOve leetcode\"));\n    }\n"}
{"task_id": "leetcode/21", "entry_point": "checkString", "prompt": "    public static boolean checkString(String s) {\n        /** Given a string s consisting of only the characters 'a' and 'b', return true if every 'a' appears before every 'b' in the string. Otherwise, return false.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        assertTrue(checkString(\"aaabbb\"));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertFalse(checkString(\"abab\"));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        assertTrue(checkString(\"bbb\"));\n    }\n"}
{"task_id": "leetcode/22", "entry_point": "isSameAfterReversals", "prompt": "    public static boolean isSameAfterReversals(int num) {\n        /** Reversing an integer means to reverse all its digits.\n         * For example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained.\n         * Given an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        assertTrue(isSameAfterReversals(526));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertFalse(isSameAfterReversals(1800));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        assertTrue(isSameAfterReversals(0));\n    }\n"}
{"task_id": "leetcode/23", "entry_point": "mostWordsFound", "prompt": "    public static int mostWordsFound(String[] sentences) {\n        /** A sentence is a list of words that are separated by a single space with no leading or trailing spaces.\n         * You are given an array of strings sentences, where each sentences[i] represents a single sentence.\n         * Return the maximum number of words that appear in a single sentence.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"alice and bob love leetcode\", \"i think so too\", \"this is great thanks very much\"};\n        assertEquals(6, mostWordsFound(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"please wait\", \"continue to fight\", \"continue to win\"};\n        assertEquals(3, mostWordsFound(arr));\n    }\n\n"}
{"task_id": "leetcode/24", "entry_point": "firstPalindrome", "prompt": "    public static String firstPalindrome(String[] words) {\n        /** Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\n         * A string is palindromic if it reads the same forward and backward.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"};\n        assertEquals(\"ada\", firstPalindrome(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"notapalindrome\",\"racecar\"};\n        assertEquals(\"racecar\", firstPalindrome(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String arr[] = {\"def\",\"ghi\"};\n        assertEquals(\"\", firstPalindrome(arr));\n    }\n\n"}
{"task_id": "leetcode/25", "entry_point": "countPoints", "prompt": "    public static int countPoints(String rings) {\n        /** There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9.\n         * You are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where:\n         * The first character of the ith pair denotes the ith ring's color ('R', 'G', 'B').\n         * The second character of the ith pair denotes the rod that the ith ring is placed on ('0' to '9').\n         * For example, \"R3G2B1\" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\n         * Return the number of rods that have all three colors of rings on them.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        assertEquals(1, countPoints(\"B0B6G0R6R0R6G9\"));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(1, countPoints(\"B0R0G0R9R0B0G0\"));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        assertEquals(0, countPoints(\"G4\"));\n    }\n\n"}
{"task_id": "leetcode/26", "entry_point": "maxSubsequence", "prompt": "    public static int[] maxSubsequence(int[] nums, int k) {\n        /** You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum.\n         * Return any such subsequence as an integer array of length k.\n         * A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {2,1,3,3};\n        int arr2[] = {3,3};\n        assertArrayEquals(arr2, maxSubsequence(arr, 2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {-1,-2,3,4};\n        int arr2[] = {-1,3,4};\n        assertArrayEquals(arr2, maxSubsequence(arr, 3));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {3,4,3,3};\n        int arr2[] = {3,4};\n        assertArrayEquals(arr2, maxSubsequence(arr, 2));\n    }\n\n"}
{"task_id": "leetcode/27", "entry_point": "findEvenNumbers", "prompt": "    public static int[] findEvenNumbers(int[] digits) {\n        /** You are given an integer array digits, where each element is a digit. The array may contain duplicates.\n         * You need to find all the unique integers that follow the given requirements:\n         * The integer consists of the concatenation of three elements from digits in any arbitrary order.\n         * The integer does not have leading zeros.\n         * The integer is even.\n         * For example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements.\n         * Return a sorted array of the unique integers.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {2,1,3,0};\n        int arr2[] = {102,120,130,132,210,230,302,310,312,320};\n        assertArrayEquals(arr2, findEvenNumbers(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {2,2,8,8,2};\n        int arr2[] = {222,228,282,288,822,828,882};\n        assertArrayEquals(arr2, findEvenNumbers(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {3,7,5};\n        int arr2[] = {};\n        assertArrayEquals(arr2, findEvenNumbers(arr));\n    }\n\n"}
{"task_id": "leetcode/28", "entry_point": "targetIndices", "prompt": "    public static List<Integer> targetIndices(int[] nums, int target) {\n        /** You are given a 0-indexed integer array nums and a target element target.\n         * A target index is an index i such that nums[i] == target.\n         * Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,2,5,2,3};\n        List<Integer> arr2 = new ArrayList<Integer>();\n        arr2.add(1);\n        arr2.add(2);\n        assertEquals(arr2, targetIndices(arr, 2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,2,5,2,3};\n        List<Integer> arr2 = new ArrayList<Integer>();\n        arr2.add(3);\n        assertEquals(arr2, targetIndices(arr, 3));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1,2,5,2,3};\n        List<Integer> arr2 = new ArrayList<Integer>();\n        arr2.add(4);\n        assertEquals(arr2, targetIndices(arr, 5));\n    }\n\n"}
{"task_id": "leetcode/29", "entry_point": "countWords", "prompt": "    public static int countWords(String[] words1, String[] words2) {\n        /** Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"};\n        String arr2[] = {\"amazing\",\"leetcode\",\"is\"};\n        assertEquals(2, countWords(arr, arr2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"b\",\"bb\",\"bbb\"};\n        String arr2[] = {\"a\",\"aa\",\"aaa\"};\n        assertEquals(0, countWords(arr, arr2));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String arr[] = {\"a\",\"ab\"};\n        String arr2[] = {\"a\",\"a\",\"a\",\"ab\"};\n        assertEquals(1, countWords(arr, arr2));\n    }"}
{"task_id": "leetcode/30", "entry_point": "maxDistance", "prompt": "    public static int maxDistance(int[] colors) {\n        /** There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.\n         * Return the maximum distance between two houses with different colors.\n         * The distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,1,1,6,1,1,1};\n        assertEquals(3, maxDistance(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,8,3,8,3};\n        assertEquals(4, maxDistance(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {0,1};\n        assertEquals(1, maxDistance(arr));\n    }\n\n"}
{"task_id": "leetcode/31", "entry_point": "timeRequiredToBuy", "prompt": "    public static int timeRequiredToBuy(int[] tickets, int k) {\n        /** There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.\n         * You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].\n         * Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.\n         * Return the time taken for the person at position k (0-indexed) to finish buying tickets.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {2,3,2};\n        assertEquals(6, timeRequiredToBuy(arr, 2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {5,1,1,1};\n        assertEquals(8, timeRequiredToBuy(arr, 0));\n    }\n"}
{"task_id": "leetcode/32", "entry_point": "checkAlmostEquivalent", "prompt": "    public static boolean checkAlmostEquivalent(String word1, String word2) {\n        /** Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\n         * Given two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\n         * The frequency of a letter x is the number of times it occurs in the string.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        String str = \"aaaa\";\n        String str2 = \"bccb\";\n        assertFalse(checkAlmostEquivalent(str, str2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"abcdeef\";\n        String str2 = \"abaaacc\";\n        assertFalse(checkAlmostEquivalent(str, str2));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"cccddabba\";\n        String str2 = \"babababab\";\n        assertFalse(checkAlmostEquivalent(str, str2));\n    }\n"}
{"task_id": "leetcode/33", "entry_point": "countVowelSubstrings", "prompt": "    public static int countVowelSubstrings(String word) {\n        /** A substring is a contiguous (non-empty) sequence of characters within a string.\n         * A vowel substring is a substring that only consists of vowels ('a', 'e', 'i', 'o', and 'u') and has all five vowels present in it.\n         * Given a string word, return the number of vowel substrings in word.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        String str = \"aeiouu\";\n        assertEquals(2, countVowelSubstrings(str));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"unicornarihan\";\n        assertEquals(0, countVowelSubstrings(str));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"cuaieuouac\";\n        assertEquals(7, countVowelSubstrings(str));\n    }\n"}
{"task_id": "leetcode/34", "entry_point": "smallestEqual", "prompt": "    public static int smallestEqual(int[] nums) {\n        /** Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.\n         * x mod y denotes the remainder when x is divided by y.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {0,1,2};\n        assertEquals(0, smallestEqual(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {4,3,2,1};\n        assertEquals(2, smallestEqual(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1,2,3,4,5,6,7,8,9,0};\n        assertEquals(-1, smallestEqual(arr));\n    }\n"}
{"task_id": "leetcode/35", "entry_point": "kthDistinct", "prompt": "    public static String kthDistinct(String[] arr, int k) {\n        /** A distinct string is a string that is present only once in an array.\n         * Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string \"\".\n         * Note that the strings are considered in the order in which they appear in the array.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"d\",\"b\",\"c\",\"b\",\"c\",\"a\"};\n        assertEquals(\"a\", kthDistinct(arr, 2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"aaa\",\"aa\",\"a\"};\n        assertEquals(\"aaa\", kthDistinct(arr, 1));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String arr[] = {\"a\",\"b\",\"a\"};\n        assertEquals(\"\", kthDistinct(arr, 3));\n    }\n"}
{"task_id": "leetcode/36", "entry_point": "countValidWords", "prompt": "    public static int countValidWords(String sentence) {\n        /** A sentence consists of lowercase letters ('a' to 'z'), digits ('0' to '9'), hyphens ('-'), punctuation marks ('!', '.', and ','), and spaces (' ') only. Each sentence can be broken down into one or more tokens separated by one or more spaces ' '.\n         * A token is a valid word if all three of the following are true:\n         * It only contains lowercase letters, hyphens, and/or punctuation (no digits).\n         * There is at most one hyphen '-'. If present, it must be surrounded by lowercase characters (\"a-b\" is valid, but \"-ab\" and \"ab-\" are not valid).\n         * There is at most one punctuation mark. If present, it must be at the end of the token (\"ab,\", \"cd!\", and \".\" are valid, but \"a!b\" and \"c.,\" are not valid).\n         * Examples of valid words include \"a-b.\", \"afad\", \"ba-c\", \"a!\", and \"!\".\n         * Given a string sentence, return the number of valid words in sentence.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        String str = \"cat and  dog\";\n        assertEquals(3, countValidWords(str));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"!this  1-s b8d!\";\n        assertEquals(0, countValidWords(str));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"alice and  bob are playing stone-game10\";\n        assertEquals(5, countValidWords(str));\n    }\n"}
{"task_id": "leetcode/37", "entry_point": "areNumbersAscending", "prompt": "    public static boolean areNumbersAscending(String s) {\n        /** A sentence is a list of tokens separated by a single space with no leading or trailing spaces. Every token is either a positive number consisting of digits 0-9 with no leading zeros, or a word consisting of lowercase English letters.\n         * For example, \"a puppy has 2 eyes 4 legs\" is a sentence with seven tokens: \"2\" and \"4\" are numbers and the other tokens such as \"puppy\" are words.\n         * Given a string s representing a sentence, you need to check if all the numbers in s are strictly increasing from left to right (i.e., other than the last number, each number is strictly smaller than the number on its right in s).\n         * Return true if so, or false otherwise.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        String str = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\";\n        assertTrue(areNumbersAscending(str));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"hello world 5 x 5\";\n        assertFalse(areNumbersAscending(str));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\";\n        assertFalse(areNumbersAscending(str));\n    }\n"}
{"task_id": "leetcode/38", "entry_point": "minMovesToSeat", "prompt": "    public static int minMovesToSeat(int[] seats, int[] students) {\n        /** There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.\n         * You may perform the following move any number of times:\n         * Increase or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1)\n         * Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat.\n         * Note that there may be multiple seats or students in the same position at the beginning.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {3,1,5};\n        int arr2[] = {2,7,4};\n        assertEquals(4, minMovesToSeat(arr, arr2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {4,1,5,9};\n        int arr2[] = {1,3,2,6};\n        assertEquals(7, minMovesToSeat(arr, arr2));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {2,2,6,6};\n        int arr2[] = {1,3,2,6};\n        assertEquals(4, minMovesToSeat(arr, arr2));\n    }\n"}
{"task_id": "leetcode/39", "entry_point": "twoOutOfThree", "prompt": "    public static List<Integer> twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) {\n        /** Given three integer arrays nums1, nums2, and nums3, return a distinct array containing all the values that are present in at least two out of the three arrays. You may return the values in any order.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,1,3,2};\n        int arr2[] = {2,3};\n        int arr3[] = {3};\n        List<Integer> arr4 = new ArrayList<Integer>();\n        arr4.add(3);\n        arr4.add(2);\n        assertEquals(arr4, twoOutOfThree(arr, arr2, arr3));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {3,1};\n        int arr2[] = {2,3};\n        int arr3[] = {1,2};\n        List<Integer> arr4 = new ArrayList<Integer>();\n        arr4.add(2);\n        arr4.add(3);\n        arr4.add(1);\n        assertEquals(arr4, twoOutOfThree(arr, arr2, arr3));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1,2,2};\n        int arr2[] = {4,3,3};\n        int arr3[] = {5};\n        List<Integer> arr4 = new ArrayList<Integer>();\n        assertEquals(arr4, twoOutOfThree(arr, arr2, arr3));\n    }\n"}
{"task_id": "leetcode/40", "entry_point": "minimumMoves", "prompt": "    public static int minimumMoves(String s) {\n        /** You are given a string s consisting of n characters which are either 'X' or 'O'.\n         * A move is defined as selecting three consecutive characters of s and converting them to 'O'. Note that if a move is applied to the character 'O', it will stay the same.\n         * Return the minimum number of moves required so that all the characters of s are converted to 'O'.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        String str = \"XXX\";\n        assertEquals(1, minimumMoves(str));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"XXOX\";\n        assertEquals(2, minimumMoves(str));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"OOOO\";\n        assertEquals(0, minimumMoves(str));\n    }\n"}
{"task_id": "leetcode/41", "entry_point": "construct2DArray", "prompt": "    public static int[][] construct2DArray(int[] original, int m, int n) {\n        /** You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with m rows and n columns using all the elements from original.\n         * The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.\n         * Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,2,3,4};\n        int arr2[][] = {\n            {1,2},\n            {3,4}\n        };\n        assertArrayEquals(arr2, construct2DArray(arr, 2, 2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,2,3};\n        int arr2[][] = {\n            {1,2,3}\n        };\n        assertArrayEquals(arr2, construct2DArray(arr, 1, 3));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1,2};\n        int arr2[][] = new int[0][0];\n        assertArrayEquals(arr2, construct2DArray(arr, 1, 1));\n    }\n"}
{"task_id": "leetcode/42", "entry_point": "maximumDifference", "prompt": "    public static int maximumDifference(int[] nums) {\n        /** Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 <= i < j < n and nums[i] < nums[j].\n         * 8 Return the maximum difference. If no such i and j exists, return -1.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {7,1,5,4};\n        assertEquals(4, maximumDifference(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {9,4,3,2};\n        assertEquals(-1, maximumDifference(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1,5,2,10};\n        assertEquals(9, maximumDifference(arr));\n    }\n"}
{"task_id": "leetcode/43", "entry_point": "finalValueAfterOperations", "prompt": "    public static int finalValueAfterOperations(String[] operations) {\n        /** There is a programming language with only four operations and one variable X:\n         * ++X and X++ increments the value of the variable X by 1.\n         * --X and X-- decrements the value of the variable X by 1.\n         * Initially, the value of X is 0.\n         * Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"--X\",\"X++\",\"X++\"};\n        assertEquals(1, finalValueAfterOperations(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"++X\",\"++X\",\"X++\"};\n        assertEquals(3, finalValueAfterOperations(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String arr[] = {\"X++\",\"++X\",\"--X\",\"X--\"};\n        assertEquals(0, finalValueAfterOperations(arr));\n    }\n"}
{"task_id": "leetcode/44", "entry_point": "countKDifference", "prompt": "    public static int countKDifference(int[] nums, int k) {\n        /** Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.\n         * The value of |x| is defined as:\n         * x if x >= 0.\n         * -x if x < 0.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,2,2,1};\n        assertEquals(4, countKDifference(arr, 1));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,3};\n        assertEquals(0, countKDifference(arr, 3));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {3,2,1,5,4};\n        assertEquals(3, countKDifference(arr, 2));\n    }\n"}
{"task_id": "leetcode/45", "entry_point": "reversePrefix", "prompt": "    public static String reversePrefix(String word, char ch) {\n        /** Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.\n         * For example, if word = \"abcdefd\" and ch = \"d\", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be \"dcbaefd\".\n         * Return the resulting string.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        String str = \"abcdefd\";\n        char ch = 'd';\n        assertEquals(\"dcbaefd\", reversePrefix(str, ch));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"xyxzxe\";\n        char ch = 'z';\n        assertEquals(\"zxyxxe\", reversePrefix(str, ch));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"abcd\";\n        char ch = 'z';\n        assertEquals(\"abcd\", reversePrefix(str, ch));\n    }\n"}
{"task_id": "leetcode/46", "entry_point": "countQuadruplets", "prompt": "    public static int countQuadruplets(int[] nums) {\n        /** Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that:\n         * nums[a] + nums[b] + nums[c] == nums[d], and\n         * a < b < c < d\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,2,3,6};\n        assertEquals(1, countQuadruplets(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {3,3,6,4,5};\n        assertEquals(0, countQuadruplets(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1,1,1,3,5};\n        assertEquals(4, countQuadruplets(arr));\n    }\n"}
{"task_id": "leetcode/47", "entry_point": "findMiddleIndex", "prompt": "    public static int findMiddleIndex(int[] nums) {\n        /** Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\n         * A middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\n         * If middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\n         * Return the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {2,3,-1,8,4};\n        assertEquals(3, findMiddleIndex(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,-1,4};\n        assertEquals(2, findMiddleIndex(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {2,5};\n        assertEquals(-1, findMiddleIndex(arr));\n    }\n"}
{"task_id": "leetcode/48", "entry_point": "minimumDifference", "prompt": "    public static int minimumDifference(int[] nums, int k) {\n        /** You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.\n         * Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.\n         * Return the minimum possible difference.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {90};\n        assertEquals(0, minimumDifference(arr, 1));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {9,4,1,7};\n        assertEquals(2, minimumDifference(arr, 2));\n    }"}
{"task_id": "leetcode/49", "entry_point": "findGCD", "prompt": "    public static int findGCD(int[] nums) {\n        /** Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.\n         * The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.\n         */\n\n", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {2,5,6,9,10};\n        assertEquals(2, findGCD(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {7,5,6,8,3};\n        assertEquals(1, findGCD(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {3,3};\n        assertEquals(3, findGCD(arr));\n    }\n"}
{"task_id": "leetcode/50", "entry_point": "minTimeToType", "prompt": "    public static int minTimeToType(String word) {\n        /** There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character 'a'.\n         * Each second, you may perform one of the following operations:\n         * Move the pointer one character counterclockwise or clockwise.\n         * Type the character the pointer is currently on.\n         * Given a string word, return the minimum number of seconds to type out the characters in word.\n         */\n\n", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        String str = \"abc\";\n        assertEquals(5, minTimeToType(str));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"bza\";\n        assertEquals(7, minTimeToType(str));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"zjpc\";\n        assertEquals(34, minTimeToType(str));\n    }\n"}
{"task_id": "leetcode/51", "entry_point": "numOfStrings", "prompt": "    public static int numOfStrings(String[] patterns, String word) {\n        /** Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word.\n         * A substring is a contiguous sequence of characters within a string.\n         */\n\n", "public_test": "\n    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"a\",\"abc\",\"bc\",\"d\"};\n        String str = \"abc\";\n        assertEquals(3, numOfStrings(arr, str));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"a\",\"b\",\"c\"};\n        String str = \"aaaaabbbbb\";\n        assertEquals(2, numOfStrings(arr, str));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String arr[] = {\"a\",\"a\",\"a\"};\n        String str = \"ab\";\n        assertEquals(3, numOfStrings(arr, str));\n    }\n"}
{"task_id": "leetcode/52", "entry_point": "isPrefixString", "prompt": "    public static boolean isPrefixString(String s, String[] words) {\n        /** Given a string s and an array of strings words, determine whether s is a prefix string of words.\n         * A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length.\n         * Return true if s is a prefix string of words, or false otherwise.\n         */\n\n", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"i\",\"love\",\"leetcode\",\"apples\"};\n        String str = \"iloveleetcode\";\n        assertTrue(isPrefixString(str, arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"apples\",\"i\",\"love\",\"leetcode\"};\n        String str = \"iloveleetcode\";\n        assertFalse(isPrefixString(str, arr));\n    }"}
{"task_id": "leetcode/53", "entry_point": "makeFancyString", "prompt": "    public static String makeFancyString(String s) {\n        /** A fancy string is a string where no three consecutive characters are equal.\n         * Given a string s, delete the minimum possible number of characters from s to make it fancy.\n         * Return the final string after the deletion. It can be shown that the answer will always be unique.\n         */\n\n", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String str = \"leeetcode\";\n        assertEquals(\"leetcode\", makeFancyString(str));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"aaabaaaa\";\n        assertEquals(\"aabaa\", makeFancyString(str));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"aab\";\n        assertEquals(\"aab\", makeFancyString(str));\n    }"}
{"task_id": "leetcode/54", "entry_point": "isThree", "prompt": "    public static boolean isThree(int n) {\n        /** Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.\n         * An integer m is a divisor of n if there exists an integer k such that n = k * m.\n         */\n\n", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        assertFalse(isThree(2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertTrue(isThree(4));\n    }"}
{"task_id": "leetcode/55", "entry_point": "getLucky", "prompt": "    public static int getLucky(String s, int k) {\n        /** You are given a string s consisting of lowercase English letters, and an integer k.\n         * First, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z' with 26). Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total.\n         * For example, if s = \"zbax\" and k = 2, then the resulting integer would be 8 by the following operations:\n         * Convert: \"zbax\" ? \"(26)(2)(1)(24)\" ? \"262124\" ? 262124\n         * Transform #1: 262124 ? 2 + 6 + 2 + 1 + 2 + 4 ? 17\n         * Transform #2: 17 ? 1 + 7 ? 8\n         * Return the resulting integer after performing the operations described above.\n         */\n\n", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String str = \"iiii\";\n        assertEquals(36, getLucky(str, 1));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"leetcode\";\n        assertEquals(6, getLucky(str, 2));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"zbax\";\n        assertEquals(8, getLucky(str, 2));\n    }"}
{"task_id": "leetcode/56", "entry_point": "areOccurrencesEqual", "prompt": "    public static boolean areOccurrencesEqual(String s) {\n        /** Given a string s, return true if s is a good string, or false otherwise.\n         * A string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency).\n         */\n\n", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        assertTrue(areOccurrencesEqual(\"abacbc\"));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertFalse(areOccurrencesEqual(\"aaabb\"));\n    }"}
{"task_id": "leetcode/57", "entry_point": "canBeTypedWords", "prompt": "    public static int canBeTypedWords(String text, String brokenLetters) {\n        /** There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly.\n         * Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard.\n         */\n\n", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String str = \"hello world\";\n        String str2 = \"ad\";\n        assertEquals(1, canBeTypedWords(str, str2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"leet code\";\n        String str2 = \"lt\";\n        assertEquals(1, canBeTypedWords(str, str2));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"leet code\";\n        String str2 = \"e\";\n        assertEquals(0, canBeTypedWords(str, str2));\n    }"}
{"task_id": "leetcode/58", "entry_point": "getConcatenation", "prompt": "    public static int[] getConcatenation(int[] nums) {\n        /** Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).\n         * Specifically, ans is the concatenation of two nums arrays.\n         * Return the array ans.\n         */\n\n", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,2,1};\n        int arr2[] = {1,2,1,1,2,1};\n        assertArrayEquals(arr2, getConcatenation(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,3,2,1};\n        int arr2[] = {1,3,2,1,1,3,2,1};\n        assertArrayEquals(arr2, getConcatenation(arr));\n    }"}
{"task_id": "leetcode/59", "entry_point": "countTriples", "prompt": "    public static int countTriples(int n) {\n        /** A square triple (a,b,c) is a triple where a, b, and c are integers and a^2 + b^2 = c^2.\n         * Given an integer n, return the number of square triples such that 1 <= a, b, c <= n.\n         */\n\n", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        assertEquals(2, countTriples(5));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(4, countTriples(10));\n    }"}
{"task_id": "leetcode/60", "entry_point": "buildArray", "prompt": "    public static int[] buildArray(int[] nums) {\n        /** Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\n         * A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).\n         */\n\n", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {0,2,1,5,3,4};\n        int arr2[] = {0,1,2,4,5,3};\n        assertArrayEquals(arr2, buildArray(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {5,0,1,2,3,4};\n        int arr2[] = {4,5,0,1,2,3};\n        assertArrayEquals(arr2, buildArray(arr));\n    }"}
