{"task_id": "leetcode/1", "entry_point": "findWinners", "prompt": "    public static List<List<Integer>> findWinners(int[][] matches) {\n        /** You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\n         *  Return a list answer of size 2 where:\n         * answer[0] is a list of all players that have not lost any matches.\n         * answer[1] is a list of all players that have lost exactly one match.\n         * The values in the two lists should be returned in increasing order.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[][] = {\n            {1,3},{2,3},{3,6},{5,6},{5,7},{4,5},{4,8},{4,9},{10,4},{10,9}\n        };\n        List l1 = Arrays.asList(1, 2, 10);\n        List l2 = Arrays.asList(4, 5, 7, 8);\n        List l3 = new ArrayList();\n        l3.add(l1);\n        l3.add(l2);\n        assertEquals(findWinners(arr), l3);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[][] = {\n            {2,3}, {1,3},\n            {5,4}, {6,4}\n        };\n        List l1 = Arrays.asList(1, 2, 5, 6);\n        List l2 = new ArrayList();\n        List l3 = new ArrayList();\n        l3.add(l1);\n        l3.add(l2);\n        assertEquals(findWinners(arr), l3);\n    }\n"}
{"task_id": "leetcode/2", "entry_point": "triangularSum", "prompt": "    public static int triangularSum(int[] nums) {\n        /** You are given a 0-indexed integer array nums, where nums[i] is a digit between 0 and 9 (inclusive).\n         * The triangular sum of nums is the value of the only element present in nums after the following process terminates:\n         * Let nums comprise of n elements. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n - 1.\n         * For each index i, where 0 <= i < n - 1, assign the value of newNums[i] as (nums[i] + nums[i+1]) % 10, where % denotes modulo operator.\n         * Replace the array nums with newNums.\n         * Repeat the entire process starting from step 1.\n         * Return the triangular sum of nums.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1, 2, 3, 4, 5};\n        assertEquals(triangularSum(arr), 8);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {5};\n        assertEquals(triangularSum(arr), 5);\n    }\n"}
{"task_id": "leetcode/3", "entry_point": "minDeletion", "prompt": "    public static int minDeletion(int[] nums) {\n        /** You are given a 0-indexed integer array nums. The array nums is beautiful if:\n         * nums.length is even.\n         * nums[i] != nums[i + 1] for all i % 2 == 0.\n         * Note that an empty array is considered beautiful.\n         * You can delete any number of elements from nums. When you delete an element, all the elements to the right of the deleted element will be shifted one unit to the left to fill the gap created and all the elements to the left of the deleted element will remain unchanged.\n         * Return the minimum number of elements to delete from nums to make it beautiful.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1, 1, 2, 3, 5};\n        assertEquals(minDeletion(arr), 1);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n       int arr[] = {1, 1, 2, 2, 3, 3};\n        assertEquals(minDeletion(arr), 2);\n    }\n"}
{"task_id": "leetcode/4", "entry_point": "countCollisions", "prompt": "    public static int countCollisions(String directions) {\n        /** There are n cars on an infinitely long road. The cars are numbered from 0 to n - 1 from left to right and each car is present at a unique point.\n         * You are given a 0-indexed string directions of length n. directions[i] can be either 'L', 'R', or 'S' denoting whether the ith car is moving towards the left, towards the right, or staying at its current point respectively. Each moving car has the same speed.\n         * The number of collisions can be calculated as follows:\n         * When two cars moving in opposite directions collide with each other, the number of collisions increases by 2.\n         * When a moving car collides with a stationary car, the number of collisions increases by 1.\n         * After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.\n         * Return the total number of collisions that will happen on the road.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        assertEquals(countCollisions(\"RLRSLL\"), 5);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(countCollisions(\"LLRR\"), 0);\n    }\n"}
{"task_id": "leetcode/5", "entry_point": "maximumSubsequenceCount", "prompt": "    public static long maximumSubsequenceCount(String text, String pattern) {\n        /** You are given a 0-indexed string text and another 0-indexed string pattern of length 2, both of which consist of only lowercase English letters.\n         * You can add either pattern[0] or pattern[1] anywhere in text exactly once. Note that the character can be added even at the beginning or at the end of text.\n         * Return the maximum number of times pattern can occur as a subsequence of the modified text.\n         * A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        assertEquals(maximumSubsequenceCount(\"abdcdbc\", \"ac\"), 4);\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(maximumSubsequenceCount(\"aabb\", \"ab\"), 6);\n    }\n"}
{"task_id": "leetcode/6", "entry_point": "digArtifacts", "prompt": "    public static int digArtifacts(int n, int[][] artifacts, int[][] dig) {\n        /** There is an n x n 0-indexed grid with some artifacts buried in it. You are given the integer n and a 0-indexed 2D integer array artifacts describing the positions of the rectangular artifacts where artifacts[i] = [r1i, c1i, r2i, c2i] denotes that the ith artifact is buried in the subgrid where:\n         * (r1i, c1i) is the coordinate of the top-left cell of the ith artifact and\n         * (r2i, c2i) is the coordinate of the bottom-right cell of the ith artifact.\n         * You will excavate some cells of the grid and remove all the mud from them. If the cell has a part of an artifact buried underneath, it will be uncovered. If all the parts of an artifact are uncovered, you can extract it.\n         * Given a 0-indexed 2D integer array dig where dig[i] = [ri, ci] indicates that you will excavate the cell (ri, ci), return the number of artifacts that you can extract.\n         * The test cases are generated such that:\n         * No two artifacts overlap.\n         * Each artifact only covers at most 4 cells.\n         * The entries of dig are unique.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[][] = {\n            {0,0,0,0},\n            {0,1,1,1}\n        };\n        int arr2[][] = {\n            {0,0},\n            {0,1}\n        };\n        assertEquals(1,digArtifacts(2, arr, arr2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[][] = {\n            {0,0,0,0},\n            {0,1,1,1}\n        };\n        int arr2[][] = {\n            {0,0},\n            {0,1},\n            {1,1}\n        };\n        assertEquals(2,digArtifacts(2, arr, arr2));\n    }\n"}
{"task_id": "leetcode/7", "entry_point": "minimalKSum", "prompt": "    public static long minimalKSum(int[] nums, int k) {\n        /** You are given an integer array nums and an integer k. Append k unique positive integers that do not appear in nums to nums such that the resulting total sum is minimum.\n         * Return the sum of the k integers appended to nums.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,4,25,10,25};\n        assertEquals(5, minimalKSum(arr, 2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {5,6};\n        assertEquals(25, minimalKSum(arr, 6));\n    }\n"}
{"task_id": "leetcode/8", "entry_point": "sortJumbled", "prompt": "    public static int[] sortJumbled(int[] mapping, int[] nums) {\n        /** You are given a 0-indexed integer array mapping which represents the mapping rule of a shuffled decimal system. mapping[i] = j means digit i should be mapped to digit j in this system.\n         * The mapped value of an integer is the new integer obtained by replacing each occurrence of digit i in the integer with mapping[i] for all 0 <= i <= 9.\n         * You are also given another integer array nums. Return the array nums sorted in non-decreasing order based on the mapped values of its elements.\n         * Notes:\n         * Elements with the same mapped values should appear in the same relative order as in the input.\n         * The elements of nums should only be sorted based on their mapped values and not be replaced by them.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {8,9,4,0,2,1,3,5,7,6};\n        int arr2[] = {991, 338, 38};\n        int arr3[] = {338,38,991};\n        assertArrayEquals(arr3, sortJumbled(arr, arr2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {0,1,2,3,4,5,6,7,8,9};\n        int arr2[] = {789,456,123};\n        int arr3[] = {123,456,789};\n        assertArrayEquals(arr3, sortJumbled(arr, arr2));\n    }\n"}
{"task_id": "leetcode/9", "entry_point": "minSteps", "prompt": "    public static int minSteps(String s, String t) {\n        /** You are given two strings s and t. In one step, you can append any character to either s or t.\n         * Return the minimum number of steps to make s and t anagrams of each other.\n         * An anagram of a string is a string that contains the same characters with a different (or the same) ordering.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String str = \"leetcode\";\n        String str2 = \"coats\";\n        assertEquals(7, minSteps(str, str2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"night\";\n        String str2 = \"thing\";\n        assertEquals(0, minSteps(str, str2));\n    }"}
{"task_id": "leetcode/11", "entry_point": "sumOfThree", "prompt": "    public static long[] sumOfThree(long num) {\n        /** Given an integer num, return three consecutive integers (as a sorted array) that sum to num. If num cannot be expressed as the sum of three consecutive integers, return an empty array.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        long arr[] = {10,11,12};\n        assertArrayEquals(arr, sumOfThree(33));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        long arr[] = {};\n        assertArrayEquals(arr, sumOfThree(4));\n    }\n"}
{"task_id": "leetcode/12", "entry_point": "minimumOperations", "prompt": "    public static int minimumOperations(int[] nums) {\n        /** You are given a 0-indexed array nums consisting of n positive integers.\n         * The array nums is called alternating if:\n         * nums[i - 2] == nums[i], where 2 <= i <= n - 1.\n         * nums[i - 1] != nums[i], where 1 <= i <= n - 1.\n         * In one operation, you can choose an index i and change nums[i] into any positive integer.\n         * Return the minimum number of operations required to make the array alternating.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {3,1,3,2,4,3};\n        assertEquals(3, minimumOperations(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,2,2,2,2};\n        assertEquals(2, minimumOperations(arr));\n    }\n"}
{"task_id": "leetcode/13", "entry_point": "smallestNumber", "prompt": "    public static long smallestNumber(long num) {\n        /** You are given an integer num. Rearrange the digits of num such that its value is minimized and it does not contain any leading zeros.\n         * Return the rearranged number with minimal value.\n         * Note that the sign of the number does not change after rearranging the digits.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        assertEquals(103, smallestNumber(310));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(-7650, smallestNumber(-7605));\n    }\n"}
{"task_id": "leetcode/14", "entry_point": "pivotArray", "prompt": "    public static int[] pivotArray(int[] nums, int pivot) {\n        /** You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n         * Every element less than pivot appears before every element greater than pivot.\n         * Every element equal to pivot appears in between the elements less than and greater than pivot.\n         * The relative order of the elements less than pivot and the elements greater than pivot is maintained.\n         * More formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n         * Return nums after the rearrangement.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {9,12,5,10,14,3,10};\n        int arr2[] = {9,5,3,10,10,12,14};\n        assertArrayEquals(arr2, pivotArray(arr, 10));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {-3,4,3,2};\n        int arr2[] = {-3,2,4,3};\n        assertArrayEquals(arr2, pivotArray(arr, 2));\n    }\n"}
{"task_id": "leetcode/15", "entry_point": "maxScoreIndices", "prompt": "    public static List<Integer> maxScoreIndices(int[] nums) {\n        /** You are given a 0-indexed binary array nums of length n. nums can be divided at index i (where 0 <= i <= n) into two arrays (possibly empty) numsleft and numsright:\n         * numsleft has all the elements of nums between index 0 and i - 1 (inclusive), while numsright has all the elements of nums between index i and n - 1 (inclusive).\n         * If i == 0, numsleft is empty, while numsright has all the elements of nums.\n         * If i == n, numsleft has all the elements of nums, while numsright is empty.\n         * The division score of an index i is the sum of the number of 0's in numsleft and the number of 1's in numsright.\n         * Return all distinct indices that have the highest possible division score. You may return the answer in any order.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {0,0,1,0};\n        List l1 = Arrays.asList(2, 4);\n        assertEquals(l1, maxScoreIndices(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {0,0,0};\n        List l1 = Arrays.asList(3);\n        assertEquals(l1, maxScoreIndices(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1,1};\n        List l1 = Arrays.asList(0);\n        assertEquals(l1, maxScoreIndices(arr));\n    }\n"}
{"task_id": "leetcode/16", "entry_point": "rearrangeArray", "prompt": "    public static int[] rearrangeArray(int[] nums) {\n        /** You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.\n         * You should rearrange the elements of nums such that the modified array follows the given conditions:\n         * Every consecutive pair of integers have opposite signs.\n         * For all integers with the same sign, the order in which they were present in nums is preserved.\n         * The rearranged array begins with a positive integer.\n         * Return the modified array after rearranging the elements to satisfy the aforementioned conditions.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {3,1,-2,-5,2,-4};\n        int arr2[] = {3,-2,1,-5,2,-4};\n        assertArrayEquals(arr2, rearrangeArray(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {-1,1};\n        int arr2[] = {1,-1};\n        assertArrayEquals(arr2, rearrangeArray(arr));\n    }"}
{"task_id": "leetcode/17", "entry_point": "numberOfArrays", "prompt": "    public static int numberOfArrays(int[] differences, int lower, int upper) {\n        /** You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers of a hidden sequence of length (n + 1). More formally, call the hidden sequence hidden, then we have that differences[i] = hidden[i + 1] - hidden[i].\n         * You are further given two integers lower and upper that describe the inclusive range of values [lower, upper] that the hidden sequence can contain.\n         * For example, given differences = [1, -3, 4], lower = 1, upper = 6, the hidden sequence is a sequence of length 4 whose elements are in between 1 and 6 (inclusive).\n         * [3, 4, 1, 5] and [4, 5, 2, 6] are possible hidden sequences.\n         * [5, 6, 3, 7] is not possible since it contains an element greater than 6.\n         * [1, 2, 3, 4] is not possible since the differences are not correct.\n         * Return the number of possible hidden sequences there are. If there are no possible sequences, return 0.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,-3,4};\n        assertEquals(2, numberOfArrays(arr,1,6));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {3,-4,5,1,-2};\n        assertEquals(4, numberOfArrays(arr,-4,5));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {4,-7,2};\n        assertEquals(0, numberOfArrays(arr,3,6));\n    }"}
{"task_id": "leetcode/18", "entry_point": "minMoves", "prompt": "    public static int minMoves(int target, int maxDoubles) {\n        /** You are playing a game with integers. You start with the integer 1 and you want to reach the integer target.\n         * In one move, you can either:\n         * Increment the current integer by one (i.e., x = x + 1).\n         * Double the current integer (i.e., x = 2 * x).\n         * You can use the increment operation any number of times, however, you can only use the double operation at most maxDoubles times.\n         * Given the two integers target and maxDoubles, return the minimum number of moves needed to reach target starting with 1.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        assertEquals(4, minMoves(5,0));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(7, minMoves(19,2));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        assertEquals(4, minMoves(10,4));\n    }"}
{"task_id": "leetcode/19", "entry_point": "minSwaps", "prompt": "    public static int minSwaps(int[] nums) {\n        /** A swap is defined as taking two distinct positions in an array and swapping the values in them.\n         * A circular array is defined as an array where we consider the first element and the last element to be adjacent.\n         * Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {0,1,0,1,1,0,0};\n        assertEquals(1, minSwaps(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {0,1,1,1,0,0,1,1,0};\n        assertEquals(2, minSwaps(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1,1,0,0,1};\n        assertEquals(0, minSwaps(arr));\n    }\n\n"}
{"task_id": "leetcode/21", "entry_point": "numberOfBeams", "prompt": "    public static int numberOfBeams(String[] bank) {\n        /** Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\n         * There is one laser beam between any two security devices if both conditions are met:\n         * The two devices are located on two different rows: r1 and r2, where r1 < r2.\n         * For each row i where r1 < i < r2, there are no security devices in the ith row.\n         * Laser beams are independent, i.e., one beam does not interfere nor join with another.\n         * Return the total number of laser beams in the bank.\n         */", "public_test": "\n\n    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"011001\",\"000000\",\"010100\",\"001000\"};\n        assertEquals(8, numberOfBeams(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"000\",\"111\",\"000\"};\n        assertEquals(0, numberOfBeams(arr));\n    }\n"}
{"task_id": "leetcode/22", "entry_point": "executeInstructions", "prompt": "    public static int[] executeInstructions(int n, int[] startPos, String s) {\n        /** There is an n x n grid, with the top-left cell at (0, 0) and the bottom-right cell at (n - 1, n - 1). You are given the integer n and an integer array startPos where startPos = [startrow, startcol] indicates that a robot is initially at cell (startrow, startcol).\n         * You are also given a 0-indexed string s of length m where s[i] is the ith instruction for the robot: 'L' (move left), 'R' (move right), 'U' (move up), and 'D' (move down).\n         * The robot can begin executing from any ith instruction in s. It executes the instructions one by one towards the end of s but it stops if either of these conditions is met:\n         * The next instruction will move the robot off the grid.\n         * There are no more instructions left to execute.\n         * Return an array answer of length m where answer[i] is the number of instructions the robot can execute if the robot begins executing from the ith instruction in s.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {0,1};\n        int arr2[] = {1,5,4,3,1,0};\n        assertArrayEquals(arr2, executeInstructions(3, arr, \"RRDDLU\"));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,1};\n        int arr2[] = {4,1,0,0};\n        assertArrayEquals(arr2, executeInstructions(2, arr, \"LURD\"));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {0,0};\n        int arr2[] = {0,0,0,0};\n        assertArrayEquals(arr2, executeInstructions(1, arr, \"LRUD\"));\n    }"}
{"task_id": "leetcode/23", "entry_point": "findAllRecipes", "prompt": "    public static List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\n        /** You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\n         * You are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\n         * Return a list of all the recipes that you can create. You may return the answer in any order.\n         * Note that two recipes may contain each other in their ingredients.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"bread\"};\n        List arr2 = new ArrayList();\n        arr2.add(Arrays.asList(\"yeast\",\"flour\"));\n        String arr3[] = {\"yeast\",\"flour\",\"corn\"};\n        List arr4 = Arrays.asList(\"bread\");\n        assertEquals(arr4, findAllRecipes(arr, arr2, arr3));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"bread\",\"sandwich\"};\n        List arr2 = new ArrayList();\n        arr2.add(Arrays.asList(\"yeast\",\"flour\"));\n        arr2.add(Arrays.asList(\"bread\",\"meat\"));\n        String arr3[] = {\"yeast\",\"flour\",\"meat\"};\n        List arr4 = Arrays.asList(\"bread\",\"sandwich\");\n        assertEquals(arr4, findAllRecipes(arr, arr2, arr3));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String arr[] = {\"bread\",\"sandwich\",\"burger\"};\n        List arr2 = new ArrayList();\n        arr2.add(Arrays.asList(\"yeast\",\"flour\"));\n        arr2.add(Arrays.asList(\"bread\",\"meat\"));\n        arr2.add(Arrays.asList(\"sandwich\",\"meat\",\"bread\"));\n        String arr3[] = {\"yeast\",\"flour\",\"meat\"};\n        List arr4 = Arrays.asList(\"bread\",\"sandwich\",\"burger\");\n        assertEquals(arr4, findAllRecipes(arr, arr2, arr3));\n    }"}
{"task_id": "leetcode/24", "entry_point": "addSpaces", "prompt": "    public static String addSpaces(String s, int[] spaces) {\n        /** You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index.\n         * For example, given s = \"EnjoyYourCoffee\" and spaces = [5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain \"Enjoy Your Coffee\".\n         * Return the modified string after the spaces have been added.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String str = \"LeetcodeHelpsMeLearn\";\n        int arr[] = {8,13,15};\n        assertEquals(\"Leetcode Helps Me Learn\", addSpaces(str, arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"icodeinpython\";\n        int arr[] = {1,5,7,9};\n        assertEquals(\"i code in py thon\", addSpaces(str, arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"spacing\";\n        int arr[] = {0,1,2,3,4,5,6};\n        assertEquals(\" s p a c i n g\", addSpaces(str, arr));\n    }"}
{"task_id": "leetcode/25", "entry_point": "subArrayRanges", "prompt": "    public static long subArrayRanges(int[] nums) {\n        /** You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.\n         * Return the sum of all subarray ranges of nums.\n         * A subarray is a contiguous non-empty sequence of elements within an array.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,2,3};\n        assertEquals(4, subArrayRanges(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,3,3};\n        assertEquals(4, subArrayRanges(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {4,-2,-3,4,1};\n        assertEquals(59, subArrayRanges(arr));\n    }"}
{"task_id": "leetcode/26", "entry_point": "goodDaysToRobBank", "prompt": "    public static List<Integer> goodDaysToRobBank(int[] security, int time) {\n        /** You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time.\n         * The ith day is a good day to rob the bank if:\n         * There are at least time days before and after the ith day,\n         * The number of guards at the bank for the time days before i are non-increasing, and\n         * The number of guards at the bank for the time days after i are non-decreasing.\n         * More formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].\n         * Return a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {5,3,3,3,5,6,2};\n        List<Integer> lst = new ArrayList<Integer>(Arrays.asList(2,3));\n        assertEquals(lst, goodDaysToRobBank(arr, 2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,1,1,1,1};\n        List<Integer> lst = new ArrayList<Integer>(Arrays.asList(0,1,2,3,4));\n        assertEquals(lst, goodDaysToRobBank(arr, 0));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1,2,3,4,5,6};\n        List<Integer> lst = new ArrayList<Integer>();\n        assertEquals(lst, goodDaysToRobBank(arr, 2));\n    }"}
{"task_id": "leetcode/28", "entry_point": "getAverages", "prompt": "    public static int[] getAverages(int[] nums, int k) {\n        /** You are given a 0-indexed array nums of n integers, and an integer k.\n         * The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i, then the k-radius average is -1.\n         * Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i.\n         * The average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part.\n         * For example, the average of four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which truncates to 2.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {7,4,3,9,1,8,5,2,6};\n        int arr2[] = {-1,-1,-1,5,4,4,-1,-1,-1};\n        assertArrayEquals(arr2, getAverages(arr, 3));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {100000};\n        int arr2[] = {100000};\n        assertArrayEquals(arr2, getAverages(arr, 0));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {8};\n        int arr2[] = {-1};\n        assertArrayEquals(arr2, getAverages(arr, 100000));\n    }"}
{"task_id": "leetcode/29", "entry_point": "minimumBuckets", "prompt": "    public static int minimumBuckets(String street) {\n        /** You are given a 0-indexed string street. Each character in street is either 'H' representing a house or '.' representing an empty space.\n         * You can place buckets on the empty spaces to collect rainwater that falls from the adjacent houses. The rainwater from a house at index i is collected if a bucket is placed at index i - 1 and/or index i + 1. A single bucket, if placed adjacent to two houses, can collect the rainwater from both houses.\n         * Return the minimum number of buckets needed so that for every house, there is at least one bucket collecting rainwater from it, or -1 if it is impossible.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String str = \"H..H\";\n        assertEquals(2, minimumBuckets(str));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \".H.H.\";\n        assertEquals(1, minimumBuckets(str));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \".HHH.\";\n        assertEquals(-1, minimumBuckets(str));\n    }"}
{"task_id": "leetcode/30", "entry_point": "wateringPlants", "prompt": "    public static int wateringPlants(int[] plants, int capacity) {\n        /** You want to water n plants in your garden with a watering can. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i. There is a river at x = -1 that you can refill your watering can at.\n         * Each plant needs a specific amount of water. You will water the plants in the following way:\n         * Water the plants in order from left to right.\n         * After watering the current plant, if you do not have enough water to completely water the next plant, return to the river to fully refill the watering can.\n         * You cannot refill the watering can early.\n         * You are initially at the river (i.e., x = -1). It takes one step to move one unit on the x-axis.\n         * Given a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and an integer capacity representing the watering can capacity, return the number of steps needed to water all the plants.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {2,2,3,3};\n        assertEquals(14, wateringPlants(arr, 5));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,1,1,4,2,3};\n        assertEquals(30, wateringPlants(arr, 4));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {7,7,7,7,7,7,7};\n        assertEquals(49, wateringPlants(arr, 8));\n    }"}
{"task_id": "leetcode/33", "entry_point": "countVowels", "prompt": "    public static long countVowels(String word) {\n        /** Given a string word, return the sum of the number of vowels ('a', 'e', 'i', 'o', and 'u') in every substring of word.\n         * A substring is a contiguous (non-empty) sequence of characters within a string.\n         * Note: Due to the large constraints, the answer may not fit in a signed 32-bit integer. Please be careful during the calculations.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        assertEquals(6, countVowels(\"aba\"));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(3, countVowels(\"abc\"));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        assertEquals(0, countVowels(\"ltcd\"));\n    }"}
{"task_id": "leetcode/35", "entry_point": "maxTwoEvents", "prompt": "    public static int maxTwoEvents(int[][] events) {\n        /** You are given a 0-indexed 2D integer array of events where events[i] = [startTimei, endTimei, valuei]. The ith event starts at startTimei and ends at endTimei, and if you attend this event, you will receive a value of valuei. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized.\n         * Return this maximum sum.\n         * Note that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time t, the next event must start at or after t + 1.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[][] = {\n            {1,3,2},\n            {4,5,2},\n            {2,4,3}\n        };\n        assertEquals(4, maxTwoEvents(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[][] = {\n            {1,3,2},\n            {4,5,2},\n            {1,5,5}\n        };\n        assertEquals(5, maxTwoEvents(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[][] = {\n            {1,5,3},\n            {1,5,1},\n            {6,6,5}\n        };\n        assertEquals(8, maxTwoEvents(arr));\n    }"}
{"task_id": "leetcode/36", "entry_point": "nextBeautifulNumber", "prompt": "    public static int nextBeautifulNumber(int n) {\n        /** An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x.\n         * Given an integer n, return the smallest numerically balanced number strictly greater than n.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        assertEquals(22, nextBeautifulNumber(1));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertEquals(1333, nextBeautifulNumber(1000));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        assertEquals(3133, nextBeautifulNumber(3000));\n    }"}
{"task_id": "leetcode/38", "entry_point": "winnerOfGame", "prompt": "    public static boolean winnerOfGame(String colors) {\n        /** There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.\n         * Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.\n         * Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.\n         * Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.\n         * Alice and Bob cannot remove pieces from the edge of the line.\n         * If a player cannot make a move on their turn, that player loses and the other player wins.\n         * Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        assertTrue(winnerOfGame(\"AAABABB\"));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        assertFalse(winnerOfGame(\"AA\"));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        assertFalse(winnerOfGame(\"ABBBBBBBAAA\"));\n    }"}
{"task_id": "leetcode/39", "entry_point": "minOperations", "prompt": "    public static int minOperations(int[][] grid, int x) {\n        /** You are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid.\n         * A uni-value grid is a grid where all the elements of it are equal.\n         * Return the minimum number of operations to make the grid uni-value. If it is not possible, return -1.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[][] = {\n            {2,4},\n            {6,8}\n        };\n        assertEquals(4, minOperations(arr, 2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[][] = {\n            {1,5},\n            {2,3}\n        };\n        assertEquals(5, minOperations(arr, 1));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[][] = {\n            {1,2},\n            {3,4}\n        };\n        assertEquals(-1, minOperations(arr, 2));\n    }"}
{"task_id": "leetcode/40", "entry_point": "missingRolls", "prompt": "    public static int[] missingRolls(int[] rolls, int mean, int n) {\n        /** You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls. Fortunately, you have also calculated the average value of the n + m rolls.\n         * You are given an integer array rolls of length m where rolls[i] is the value of the ith observation. You are also given the two integers mean and n.\n         * Return an array of length n containing the missing observations such that the average value of the n + m rolls is exactly mean. If there are multiple valid answers, return any of them. If no such array exists, return an empty array.\n         * The average value of a set of k numbers is the sum of the numbers divided by k.\n         * Note that mean is an integer, so the sum of the n + m rolls should be divisible by n + m.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {3,2,4,3};\n        int arr2[] = {6,6};\n        assertArrayEquals(arr2, missingRolls(arr, 4, 2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {1,5,6};\n        int arr2[] = {2,3,2,2};\n        assertArrayEquals(arr2, missingRolls(arr, 3, 4));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1,2,3,4};\n        int arr2[] = {};\n        assertArrayEquals(arr2, missingRolls(arr, 6, 4));\n    }"}
{"task_id": "leetcode/41", "entry_point": "numOfPairs", "prompt": "    public static int numOfPairs(String[] nums, String target) {\n        /** Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"777\",\"7\",\"77\",\"77\"};\n        assertEquals(4, numOfPairs(arr, \"7777\"));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"123\",\"4\",\"12\",\"34\"};\n        assertEquals(2, numOfPairs(arr, \"1234\"));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String arr[] = {\"1\",\"1\",\"1\"};\n        assertEquals(6, numOfPairs(arr, \"11\"));\n    }"}
{"task_id": "leetcode/42", "entry_point": "gridGame", "prompt": "    public static long gridGame(int[][] grid) {\n        /** You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\n         * Both robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\n         * At the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\n         * The first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[][] = {\n            {2,5,4},\n            {1,5,1}\n        };\n        assertEquals(4, gridGame(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[][] = {\n            {3,3,1},\n            {8,5,2}\n        };\n        assertEquals(4, gridGame(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[][] = {\n            {1,3,1,15},\n            {1,3,3,1}\n        };\n        assertEquals(7, gridGame(arr));\n    }"}
{"task_id": "leetcode/43", "entry_point": "sumOfBeauties", "prompt": "    public static int sumOfBeauties(int[] nums) {\n        /** You are given a 0-indexed integer array nums. For each index i (1 <= i <= nums.length - 2) the beauty of nums[i] equals:\n         * 2, if nums[j] < nums[i] < nums[k], for all 0 <= j < i and for all i < k <= nums.length - 1.\n         * 1, if nums[i - 1] < nums[i] < nums[i + 1], and the previous condition is not satisfied.\n         * 0, if none of the previous conditions holds.\n         * Return the sum of beauty of all nums[i] where 1 <= i <= nums.length - 2.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,2,3};\n        assertEquals(2, sumOfBeauties(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {2,4,6,4};\n        assertEquals(1, sumOfBeauties(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {3,2,1};\n        assertEquals(0, sumOfBeauties(arr));\n    }"}
{"task_id": "leetcode/44", "entry_point": "findOriginalArray", "prompt": "    public static int[] findOriginalArray(int[] changed) {\n        /** An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.\n         * Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,3,4,2,6,8};\n        int arr2[] = {1,3,4};\n        assertArrayEquals(arr2, findOriginalArray(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {6,3,0,1};\n        int arr2[] = {};\n        assertArrayEquals(arr2, findOriginalArray(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1};\n        int arr2[] = {};\n        assertArrayEquals(arr2, findOriginalArray(arr));\n    }"}
{"task_id": "leetcode/45", "entry_point": "interchangeableRectangles", "prompt": "    public static long interchangeableRectangles(int[][] rectangles) {\n        /** You are given n rectangles represented by a 0-indexed 2D integer array rectangles, where rectangles[i] = [widthi, heighti] denotes the width and height of the ith rectangle.\n         * Two rectangles i and j (i < j) are considered interchangeable if they have the same width-to-height ratio. More formally, two rectangles are interchangeable if widthi/heighti == widthj/heightj (using decimal division, not integer division).\n         * Return the number of pairs of interchangeable rectangles in rectangles.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[][] = {\n            {4,8}, {3,6},\n            {10,20}, {15,30}\n        };\n        assertEquals(6, interchangeableRectangles(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[][] = {\n            {4,5}, {7,8}\n        };\n        assertEquals(0, interchangeableRectangles(arr));\n    }\n"}
{"task_id": "leetcode/46", "entry_point": "numberOfWeakCharacters", "prompt": "    public static int numberOfWeakCharacters(int[][] properties) {\n        /** You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.\n         * A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei.\n         * Return the number of weak characters.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[][] = {\n            {5,5}, {6,3},\n            {3,6}\n        };\n        assertEquals(0, numberOfWeakCharacters(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[][] = {\n            {2,2}, {3,3}\n        };\n        assertEquals(1, numberOfWeakCharacters(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[][] = {\n            {1,5}, {10,4}, {4,3}\n        };\n        assertEquals(1, numberOfWeakCharacters(arr));\n    }\n"}
{"task_id": "leetcode/47", "entry_point": "findFarmland", "prompt": "    public static int[][] findFarmland(int[][] land) {\n        /** You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.\n         * To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.\n         * land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].\n         * Return a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[][] = {\n            {1,0,0},\n            {0,1,1},\n            {0,1,1}\n        };\n        int arr2[][] = {\n            {0,0,0,0},\n            {1,1,2,2}\n        };\n        assertArrayEquals(arr2, findFarmland(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[][] = {\n            {1,1},\n            {1,1}\n        };\n        int arr2[][] = {\n            {0,0,1,1}\n        };\n        assertArrayEquals(arr2, findFarmland(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[][] = {\n            {0}\n        };\n        int arr2[][] = {\n            {}\n        };\n        assertArrayEquals(arr2, findFarmland(arr));\n    }\n"}
{"task_id": "leetcode/48", "entry_point": "kthLargestNumber", "prompt": "    public static String kthLargestNumber(String[] nums, int k) {\n        /** You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.\n         * Return the string that represents the kth largest integer in nums.\n         * Note: Duplicate numbers should be counted distinctly. For example, if nums is [\"1\",\"2\",\"2\"], \"2\" is the first largest integer, \"2\" is the second-largest integer, and \"1\" is the third-largest integer.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"3\",\"6\",\"7\",\"10\"};\n        assertEquals(\"3\", kthLargestNumber(arr,4));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"2\",\"21\",\"12\",\"1\"};\n        assertEquals(\"2\", kthLargestNumber(arr,3));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String arr[] = {\"0\",\"0\"};\n        assertEquals(\"0\", kthLargestNumber(arr,2));\n    }\n"}
{"task_id": "leetcode/49", "entry_point": "findDifferentBinaryString", "prompt": "    public static String findDifferentBinaryString(String[] nums) {\n        /** Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String arr[] = {\"01\",\"10\"};\n        assertEquals(\"11\", findDifferentBinaryString(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String arr[] = {\"00\",\"01\"};\n        assertEquals(\"11\", findDifferentBinaryString(arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String arr[] = {\"111\",\"011\",\"001\"};\n        assertEquals(\"101\", findDifferentBinaryString(arr));\n    }\n"}
{"task_id": "leetcode/50", "entry_point": "maxMatrixSum", "prompt": "    public static long maxMatrixSum(int[][] matrix) {\n        /** You are given an n x n integer matrix. You can do the following operation any number of times:\n         * Choose any two adjacent elements of matrix and multiply each of them by -1.\n         * Two elements are considered adjacent if and only if they share a border.\n         * Your goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[][] = {\n            {1,-1}, {-1,1},\n        };\n        assertEquals(4, maxMatrixSum(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[][] = {\n            {1,2,3}, {-1,-2,-3},{1,2,3}\n        };\n        assertEquals(16, maxMatrixSum(arr));\n    }"}
{"task_id": "leetcode/51", "entry_point": "rearrangeArray", "prompt": "    public static int[] rearrangeArray(int[] nums) {\n        /** You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\n         * More formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\n         * Return any rearrangement of nums that meets the requirements.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,2,3,4,5};\n        int arr2[] = {1,2,4,5,3};\n        assertArrayEquals(arr2, rearrangeArray(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {6,2,0,9,7};\n        int arr2[] = {9,7,6,2,0};\n        assertArrayEquals(arr2, rearrangeArray(arr));\n    }"}
{"task_id": "leetcode/52", "entry_point": "minStoneSum", "prompt": "    public static int minStoneSum(int[] piles, int k) {\n        /** You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:\n         * Choose any piles[i] and remove floor(piles[i] / 2) stones from it.\n         * Notice that you can apply the operation on the same pile more than once.\n         * Return the minimum possible total number of stones remaining after applying the k operations.\n         * floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {5,4,9};\n        assertEquals(12, minStoneSum(arr, 2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {4,3,6,7};\n        assertEquals(12, minStoneSum(arr, 3));\n    }"}
{"task_id": "leetcode/53", "entry_point": "checkMove", "prompt": "    public static boolean checkMove(char[][] board, int rMove, int cMove, char color) {\n        /** You are given a 0-indexed 8 x 8 grid board, where board[r][c] represents the cell (r, c) on a game board. On the board, free cells are represented by '.', white cells are represented by 'W', and black cells are represented by 'B'.\n         * Each move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). However, a move is only legal if, after changing it, the cell becomes the endpoint of a good line (horizontal, vertical, or diagonal).\n         * A good line is a line of three or more cells (including the endpoints) where the endpoints of the line are one color, and the remaining cells in the middle are the opposite color (no cells in the line are free). You can find examples for good lines in the figure below:\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        char arr[][] = {\n            {'.','.','.','B','.','.','.','.'},\n            {'.','.','.','W','.','.','.','.'},\n            {'.','.','.','W','.','.','.','.'},\n            {'.','.','.','W','.','.','.','.'},\n            {'W','B','B','.','W','W','W','B'},\n            {'.','.','.','B','.','.','.','.'},\n            {'.','.','.','B','.','.','.','.'},\n            {'.','.','.','W','.','.','.','.'}\n        };\n        assertTrue(checkMove(arr, 4, 3, 'B'));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        char arr[][] = {\n            {'.','.','.','.','.','.','.','.'},\n            {'.','B','.','.','W','.','.','.'},\n            {'.','.','W','.','.','.','.','.'},\n            {'.','.','.','W','B','.','.','.'},\n            {'.','.','.','.','.','.','.','.'},\n            {'.','.','.','.','B','W','.','.'},\n            {'.','.','.','.','.','.','W','.'},\n            {'.','.','.','.','.','.','.','B'}\n            };\n        assertTrue(checkMove(arr, 4, 4, 'W'));\n    }"}
{"task_id": "leetcode/54", "entry_point": "numberOfWeeks", "prompt": "    public static long numberOfWeeks(int[] milestones) {\n        /** There are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has.\n         * You can work on the projects following these two rules:\n         * Every week, you will finish exactly one milestone of one project. You must work every week.\n         * You cannot work on two milestones from the same project for two consecutive weeks.\n         * Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. Note that you may not be able to finish every project's milestones due to these constraints.\n         * Return the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,2,3};\n        assertEquals(6, numberOfWeeks(arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {5,2,1};\n        assertEquals(7, numberOfWeeks(arr));\n    }"}
{"task_id": "leetcode/55", "entry_point": "maximumNumber", "prompt": "    public static String maximumNumber(String num, int[] change) {\n        /** You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\n         * You may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\n         * Return a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\n         * A substring is a contiguous sequence of characters within the string.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {9,8,5,0,3,6,4,2,6,8};\n        assertEquals(\"832\", maximumNumber(\"132\",arr));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {9,4,3,5,7,2,1,9,0,6};\n        assertEquals(\"934\", maximumNumber(\"021\",arr));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {1,4,7,5,3,2,5,6,9,4};\n        assertEquals(\"5\", maximumNumber(\"5\",arr));\n    }"}
{"task_id": "leetcode/56", "entry_point": "smallestChair", "prompt": "    public static int smallestChair(int[][] times, int targetFriend) {\n        /** There is a party where n friends numbered from 0 to n - 1 are attending. There is an infinite number of chairs in this party that are numbered from 0 to infinity. When a friend arrives at the party, they sit on the unoccupied chair with the smallest number.\n         * For example, if chairs 0, 1, and 5 are occupied when a friend comes, they will sit on chair number 2.\n         * When a friend leaves the party, their chair becomes unoccupied at the moment they leave. If another friend arrives at that same moment, they can sit in that chair.\n         * You are given a 0-indexed 2D integer array times where times[i] = [arrivali, leavingi], indicating the arrival and leaving times of the ith friend respectively, and an integer targetFriend. All arrival times are distinct.\n         * Return the chair number that the friend numbered targetFriend will sit on.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[][] = {\n            {1,4},\n            {2,3},\n            {4,6}\n        };\n        assertEquals(1, smallestChair(arr, 1));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[][] = {\n            {3,10},\n            {1,5},\n            {2,6}\n        };\n        assertEquals(2, smallestChair(arr, 0));\n    }\n"}
{"task_id": "leetcode/57", "entry_point": "addRungs", "prompt": "    public static int addRungs(int[] rungs, int dist) {\n        /** You are given a strictly increasing integer array rungs that represents the height of rungs on a ladder. You are currently on the floor at height 0, and you want to reach the last rung.\n         * You are also given an integer dist. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is at most dist. You are able to insert rungs at any positive integer height if a rung is not already there.\n         * Return the minimum number of rungs that must be added to the ladder in order for you to climb to the last rung.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,3,5,10};\n        assertEquals(2, addRungs(arr, 2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {3,6,8,10};\n        assertEquals(0, addRungs(arr, 3));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        int arr[] = {3,4,6,7};\n        assertEquals(1, addRungs(arr, 2));\n    }\n"}
{"task_id": "leetcode/58", "entry_point": "countPalindromicSubsequence", "prompt": "    public static int countPalindromicSubsequence(String s) {\n        /** Given a string s, return the number of unique palindromes of length three that are a subsequence of s.\n         * Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.\n         * A palindrome is a string that reads the same forwards and backwards.\n         * A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n         * For example, \"ace\" is a subsequence of \"abcde\".\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        String str = \"aabca\";\n        assertEquals(3, countPalindromicSubsequence(str));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        String str = \"aabca\";\n        assertEquals(3, countPalindromicSubsequence(str));\n    }\n\n    @Test(timeout=500)\n    public void test3(){\n        String str = \"bbcbaba\";\n        assertEquals(4, countPalindromicSubsequence(str));\n    }\n"}
{"task_id": "leetcode/59", "entry_point": "nearestExit", "prompt": "    public static int nearestExit(char[][] maze, int[] entrance) {\n        /** You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.\n         * In one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit.\n         * Return the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        char arr[][] = {\n            {'+','+','.','+'},\n            {'.','.','.','+'},\n            {'+','+','+','.'}\n        };\n        int arr2[] = {1,2};\n        assertEquals(1, nearestExit(arr, arr2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        char arr[][] = {\n            {'+','+','+'},\n            {'.','.','.'},\n            {'+','+','+'}\n        };\n        int arr2[] = {1,0};\n        assertEquals(2, nearestExit(arr, arr2));\n    }\n    \n    @Test(timeout=500)\n    public void test3(){\n        char arr[][] = {\n            {'.', '+'}\n        };\n        int arr2[] = {0,0};\n        assertEquals(-1, nearestExit(arr, arr2));\n    }"}
{"task_id": "leetcode/60", "entry_point": "eliminateMaximum", "prompt": "    public static int eliminateMaximum(int[] dist, int[] speed) {\n        /** You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.\n         * The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.\n         * You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge.The weapon is fully charged at the very start.\n         * You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.\n         * Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.\n         */", "public_test": "    @Test(timeout=500)\n    public void test1(){\n        int arr[] = {1,1,2,3};\n        int arr2[] = {1,1,1,1};\n        assertEquals(1, eliminateMaximum(arr, arr2));\n    }\n\n    @Test(timeout=500)\n    public void test2(){\n        int arr[] = {3,2,4};\n        int arr2[] = {5,3,2};\n        assertEquals(1, eliminateMaximum(arr, arr2));\n    }\n"}
